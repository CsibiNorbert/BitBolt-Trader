@inject IJSRuntime JSRuntime
@inject ILogger<TradingViewChartInterop> Logger
@implements IAsyncDisposable

<div id="@ChartId" class="tradingview-chart" style="width: 100%; height: @Height; background: #1a1a1a; position: relative;">
    @if (IsLoading)
    {
        <div class="d-flex justify-content-center align-items-center h-100">
            <div class="text-center">
                <div class="spinner-border text-primary mb-3" role="status">
                    <span class="visually-hidden">Loading chart...</span>
                </div>
                <p class="text-light">Loading @Title chart...</p>
            </div>
        </div>
    }
    else if (HasError)
    {
        <div class="d-flex justify-content-center align-items-center h-100">
            <div class="text-center text-danger">
                <i class="fas fa-exclamation-triangle fa-3x mb-3"></i>
                <h5>Chart Error</h5>
                <p>@ErrorMessage</p>
                <button class="btn btn-outline-primary btn-sm" @onclick="RefreshChart">
                    <i class="fas fa-sync me-1"></i>Retry
                </button>
            </div>
        </div>
    }
</div>

@code {
    [Parameter] public string Title { get; set; } = "BTC/USDT";
    [Parameter] public string Height { get; set; } = "500px";
    [Parameter] public string Symbol { get; set; } = "BTCUSDT";
    [Parameter] public EventCallback<string> OnTimeframeChanged { get; set; }
    [Parameter] public EventCallback OnChartReady { get; set; }

    private string ChartId = Guid.NewGuid().ToString("N")[..8];
    private bool IsLoading = true;
    private bool HasError = false;
    private string ErrorMessage = string.Empty;
    private Timer? _updateTimer;
    private List<object> _candlestickData = new();
    private List<object> _volumeData = new();
    private List<object> _markers = new();

    // Store last candle data for updates
    private double _lastPrice = 67000;
    private long _lastTime = 0;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await InitializeChart();
        }
    }

    private async Task InitializeChart()
    {
        try
        {
            IsLoading = true;
            HasError = false;
            StateHasChanged();

            Logger.LogInformation("Initializing TradingView chart with ID: {ChartId}", ChartId);

            // Wait for DOM to be ready
            await Task.Delay(500);

            // Generate sample data
            GenerateSampleData();

            // Create chart options
            var options = new
            {
                height = 500,
                width = -1 // Responsive
            };

            // Create the chart
            var success = await JSRuntime.InvokeAsync<bool>("TradingViewInterop.createChart", ChartId, options);

            if (success)
            {
                // Load initial data
                await UpdateChartData();

                // Start real-time updates
                StartUpdateTimer();

                Logger.LogInformation("TradingView chart initialized successfully");
                await OnChartReady.InvokeAsync();
                
                IsLoading = false;
                StateHasChanged();
            }
            else
            {
                throw new Exception("Failed to create chart in JavaScript");
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to initialize TradingView chart: {Message}", ex.Message);
            HasError = true;
            ErrorMessage = $"Failed to initialize chart: {ex.Message}";
            IsLoading = false;
            StateHasChanged();
        }
    }

    private void GenerateSampleData()
    {
        var random = new Random();
        var basePrice = 67000.0;
        var baseTime = DateTimeOffset.UtcNow.AddHours(-2);
        
        _candlestickData.Clear();
        _volumeData.Clear();

        for (int i = 0; i < 100; i++)
        {
            var time = baseTime.AddMinutes(i * 1).ToUnixTimeSeconds();
            var open = basePrice + (random.NextDouble() * 2000 - 1000);
            var close = open + (random.NextDouble() * 1000 - 500);
            var high = Math.Max(open, close) + (random.NextDouble() * 300);
            var low = Math.Min(open, close) - (random.NextDouble() * 300);
            var volume = random.NextDouble() * 1000 + 100;

            _candlestickData.Add(new
            {
                time = time,
                open = Math.Round(open, 2),
                high = Math.Round(high, 2),
                low = Math.Round(low, 2),
                close = Math.Round(close, 2)
            });

            _volumeData.Add(new
            {
                time = time,
                value = Math.Round(volume, 2),
                color = close > open ? "#26a69a" : "#ef5350"
            });

            basePrice = close;
            _lastPrice = close;
            _lastTime = time;
        }

        // Add sample markers
        var buyTime = baseTime.AddMinutes(25).ToUnixTimeSeconds();
        var sellTime = baseTime.AddMinutes(75).ToUnixTimeSeconds();

        _markers.Add(new
        {
            time = buyTime,
            position = "belowBar",
            color = "#26a69a",
            shape = "arrowUp",
            text = "BUY"
        });

        _markers.Add(new
        {
            time = sellTime,
            position = "aboveBar",
            color = "#ef5350",
            shape = "arrowDown",
            text = "SELL"
        });
    }

    private async Task UpdateChartData()
    {
        try
        {
            Logger.LogInformation("Updating chart data with {CandleCount} candles", _candlestickData.Count);
            await JSRuntime.InvokeVoidAsync("TradingViewInterop.updateChartData", 
                ChartId, _candlestickData, _volumeData, _markers);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to update chart data: {Message}", ex.Message);
            throw;
        }
    }

    private void StartUpdateTimer()
    {
        _updateTimer = new Timer(async _ =>
        {
            try
            {
                var random = new Random();
                var currentTime = DateTimeOffset.UtcNow.ToUnixTimeSeconds();
                var priceChange = (random.NextDouble() * 200 - 100);
                var newPrice = _lastPrice + priceChange;
                var volume = random.NextDouble() * 100 + 50;

                var newCandle = new
                {
                    time = currentTime,
                    open = Math.Round(_lastPrice, 2),
                    high = Math.Round(Math.Max(_lastPrice, newPrice) + random.NextDouble() * 50, 2),
                    low = Math.Round(Math.Min(_lastPrice, newPrice) - random.NextDouble() * 50, 2),
                    close = Math.Round(newPrice, 2)
                };

                var newVolume = new
                {
                    time = currentTime,
                    value = Math.Round(volume, 2),
                    color = newPrice > _lastPrice ? "#26a69a" : "#ef5350"
                };

                await InvokeAsync(async () =>
                {
                    await JSRuntime.InvokeVoidAsync("TradingViewInterop.addNewCandle", 
                        ChartId, newCandle, newVolume);
                });

                _lastPrice = newPrice;
                _lastTime = currentTime;
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error in real-time update: {Message}", ex.Message);
            }
        }, null, TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(5));
    }

    public async Task RefreshChart()
    {
        try
        {
            HasError = false;
            ErrorMessage = string.Empty;
            StateHasChanged();
            
            await JSRuntime.InvokeVoidAsync("TradingViewInterop.destroyChart", ChartId);
            await Task.Delay(100);
            await InitializeChart();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to refresh chart: {Message}", ex.Message);
            HasError = true;
            ErrorMessage = $"Failed to refresh chart: {ex.Message}";
            StateHasChanged();
        }
    }

    public async Task AddSignalMarker(string signalType, decimal price, string strategy = "Keltner")
    {
        try
        {
            var marker = new
            {
                time = DateTimeOffset.UtcNow.ToUnixTimeSeconds(),
                position = signalType.ToUpper() == "BUY" ? "belowBar" : "aboveBar",
                color = signalType.ToUpper() == "BUY" ? "#26a69a" : "#ef5350",
                shape = signalType.ToUpper() == "BUY" ? "arrowUp" : "arrowDown",
                text = $"{signalType.ToUpper()}"
            };

            await JSRuntime.InvokeVoidAsync("TradingViewInterop.addMarker", ChartId, marker);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to add signal marker: {Message}", ex.Message);
        }
    }

    public async ValueTask DisposeAsync()
    {
        _updateTimer?.Dispose();
        
        try
        {
            await JSRuntime.InvokeVoidAsync("TradingViewInterop.destroyChart", ChartId);
        }
        catch (Exception ex)
        {
            Logger.LogDebug(ex, "Error disposing chart - this is normal during shutdown");
        }
        
        Logger.LogDebug("TradingViewChartInterop disposed");
    }
} 